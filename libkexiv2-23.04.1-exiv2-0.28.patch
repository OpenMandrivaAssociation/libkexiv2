diff -up libkexiv2-23.04.1/src/kexiv2comments.cpp.omv~ libkexiv2-23.04.1/src/kexiv2comments.cpp
--- libkexiv2-23.04.1/src/kexiv2comments.cpp.omv~	2023-05-18 03:02:52.995760668 +0200
+++ libkexiv2-23.04.1/src/kexiv2comments.cpp	2023-05-18 03:04:21.339638968 +0200
@@ -18,7 +18,12 @@ bool KExiv2::canWriteComment(const QStri
 {
     try
     {
-        Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((const char*)
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image
+#else
+        Exiv2::Image::AutoPtr image
+#endif
+                                    = Exiv2::ImageFactory::open((const char*)
                                       (QFile::encodeName(filePath).constData()));
 
         Exiv2::AccessMode mode = image->checkMode(Exiv2::mdComment);
@@ -28,7 +33,12 @@ bool KExiv2::canWriteComment(const QStri
     {
         std::string s(e.what());
         qCCritical(LIBKEXIV2_LOG) << "Cannot check Comment access mode using Exiv2 (Error #"
-                                  << e.code() << ": " << s.c_str() << ")";
+#if EXIV2_TEST_VERSION(0,28,0)
+                                  << Exiv2::Error(e.code()).what()
+#else
+                                  << e.code() << ": " << s.c_str()
+#endif
+                                  << ")";
     }
     catch(...)
     {
diff -up libkexiv2-23.04.1/src/kexiv2.cpp.omv~ libkexiv2-23.04.1/src/kexiv2.cpp
--- libkexiv2-23.04.1/src/kexiv2.cpp.omv~	2023-05-18 02:49:38.866743818 +0200
+++ libkexiv2-23.04.1/src/kexiv2.cpp	2023-05-18 03:08:27.846083292 +0200
@@ -207,7 +207,11 @@ bool KExiv2::loadFromData(const QByteArr
 
     try
     {
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open((Exiv2::byte*)imgData.data(), imgData.size());
+#else
         Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((Exiv2::byte*)imgData.data(), imgData.size());
+#endif
 
         d->filePath.clear();
         image->readMetadata();
@@ -263,7 +267,11 @@ bool KExiv2::load(const QString& filePat
 
     try
     {
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image;
+#else
         Exiv2::Image::AutoPtr image;
+#endif
 
         image        = Exiv2::ImageFactory::open((const char*)(QFile::encodeName(filePath)).constData());
 
@@ -312,7 +320,11 @@ bool KExiv2::load(const QString& filePat
             QString xmpSidecarPath = sidecarFilePathForFile(filePath);
             QFileInfo xmpSidecarFileInfo(xmpSidecarPath);
 
+#if EXIV2_TEST_VERSION(0,28,0)
+            Exiv2::Image::UniquePtr xmpsidecar;
+#else
             Exiv2::Image::AutoPtr xmpsidecar;
+#endif
 
             if (xmpSidecarFileInfo.exists() && xmpSidecarFileInfo.isReadable())
             {
@@ -321,7 +333,11 @@ bool KExiv2::load(const QString& filePat
                 xmpsidecar->readMetadata();
 
                 // Merge
+#if EXIV2_TEST_VERSION(0,28,0)
+                d->loadSidecarData(std::move(xmpsidecar));
+#else
                 d->loadSidecarData(xmpsidecar);
+#endif
                 hasLoaded = true;
             }
         }
diff -up libkexiv2-23.04.1/src/kexiv2exif.cpp.omv~ libkexiv2-23.04.1/src/kexiv2exif.cpp
--- libkexiv2-23.04.1/src/kexiv2exif.cpp.omv~	2023-05-18 02:37:25.307720749 +0200
+++ libkexiv2-23.04.1/src/kexiv2exif.cpp	2023-05-18 02:49:25.227602754 +0200
@@ -29,7 +29,12 @@ bool KExiv2::canWriteExif(const QString&
 {
     try
     {
-        Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((const char*)
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image =
+#else
+        Exiv2::Image::AutoPtr image =
+#endif
+                                      Exiv2::ImageFactory::open((const char*)
                                       (QFile::encodeName(filePath).constData()));
 
         Exiv2::AccessMode mode = image->checkMode(Exiv2::mdExif);
@@ -40,7 +45,12 @@ bool KExiv2::canWriteExif(const QString&
     {
         std::string s(e.what());
         qCCritical(LIBKEXIV2_LOG) << "Cannot check Exif access mode using Exiv2 (Error #"
-                    << e.code() << ": " << s.c_str() << ")";
+#if EXIV2_TEST_VERSION(0,28,0)
+                    << Exiv2::Error(e.code()).what()
+#else
+                    << e.code() << ": " << s.c_str()
+#endif
+                    << ")";
     }
     catch(...)
     {
@@ -675,7 +685,11 @@ bool KExiv2::getExifTagLong(const char*
 
         if (it != exifData.end() && it->count() > 0)
         {
+#if EXIV2_TEST_VERSION(0,28,0)
+            val = it->toUint32(component);
+#else
             val = it->toLong(component);
+#endif
             return true;
         }
     }
@@ -739,7 +753,11 @@ QVariant KExiv2::getExifTagVariant(const
                 case Exiv2::signedShort:
                 case Exiv2::signedLong:
                     if (it->count() > component)
+#if EXIV2_TEST_VERSION(0,28,0)
+                        return QVariant((int)it->toUint32(component));
+#else
                         return QVariant((int)it->toLong(component));
+#endif
                     else
                         return QVariant(QVariant::Int);
                 case Exiv2::unsignedRational:
@@ -871,7 +889,11 @@ QImage KExiv2::getExifThumbnail(bool fix
     {
         Exiv2::ExifThumbC thumb(d->exifMetadata());
         Exiv2::DataBuf const c1 = thumb.copy();
+#if EXIV2_TEST_VERSION(0,28,0)
+        thumbnail.loadFromData(c1.c_data(), c1.size());
+#else
         thumbnail.loadFromData(c1.pData_, c1.size_);
+#endif
 
         if (!thumbnail.isNull())
         {
@@ -887,7 +909,11 @@ QImage KExiv2::getExifThumbnail(bool fix
 
                 if (it != exifData.end() && it->count())
                 {
+#if EXIV2_TEST_VERSION(0,28,0)
+                    long orientation = it->toUint32();
+#else
                     long orientation = it->toLong();
+#endif
                     qCDebug(LIBKEXIV2_LOG) << "Exif Thumbnail Orientation: " << (int)orientation;
                     rotateExifQImage(thumbnail, (ImageOrientation)orientation);
                 }
@@ -965,9 +991,15 @@ bool KExiv2::setTiffThumbnail(const QIma
         // Make sure IFD0 is explicitly marked as a main image
         Exiv2::ExifData::const_iterator pos = d->exifMetadata().findKey(Exiv2::ExifKey("Exif.Image.NewSubfileType"));
 
+#if EXIV2_TEST_VERSION(0,28,0)
+        if (pos == d->exifMetadata().end() || pos->count() != 1 || pos->toUint32() != 0)
+#else
         if (pos == d->exifMetadata().end() || pos->count() != 1 || pos->toLong() != 0)
+#endif
         {
-#if EXIV2_TEST_VERSION(0,27,0)
+#if EXIV2_TEST_VERSION(0,28,0)
+            throw Exiv2::Error(Exiv2::ErrorCode::kerErrorMessage, "Exif.Image.NewSubfileType missing or not set as main image");
+#elif EXIV2_TEST_VERSION(0,27,0)
             throw Exiv2::Error(Exiv2::kerErrorMessage, "Exif.Image.NewSubfileType missing or not set as main image");
 #else
             throw Exiv2::Error(1, "Exif.Image.NewSubfileType missing or not set as main image");
@@ -996,9 +1028,17 @@ bool KExiv2::setTiffThumbnail(const QIma
             Exiv2::DataBuf buf((Exiv2::byte *)data.data(), data.size());
             Exiv2::ULongValue val;
             val.read("0");
+#if EXIV2_TEST_VERSION(0,28,0)
+            val.setDataArea(buf.c_data(), buf.size());
+#else
             val.setDataArea(buf.pData_, buf.size_);
+#endif
             d->exifMetadata()["Exif.SubImage1.JPEGInterchangeFormat"]       = val;
+#if EXIV2_TEST_VERSION(0,28,0)
+            d->exifMetadata()["Exif.SubImage1.JPEGInterchangeFormatLength"] = uint32_t(buf.size());
+#else
             d->exifMetadata()["Exif.SubImage1.JPEGInterchangeFormatLength"] = uint32_t(buf.size_);
+#endif
             d->exifMetadata()["Exif.SubImage1.Compression"]                 = uint16_t(6); // JPEG (old-style)
             d->exifMetadata()["Exif.SubImage1.NewSubfileType"]              = uint32_t(1); // Thumbnail image
             return true;
diff -up libkexiv2-23.04.1/src/kexiv2gps.cpp.omv~ libkexiv2-23.04.1/src/kexiv2gps.cpp
--- libkexiv2-23.04.1/src/kexiv2gps.cpp.omv~	2023-05-18 03:01:29.414928266 +0200
+++ libkexiv2-23.04.1/src/kexiv2gps.cpp	2023-05-18 03:02:10.386336502 +0200
@@ -325,7 +325,11 @@ bool KExiv2::initializeGPSInfo(const boo
         // Do all the easy constant ones first.
         // GPSVersionID tag: standard says is should be four bytes: 02 00 00 00
         // (and, must be present).
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Value::UniquePtr value = Exiv2::Value::create(Exiv2::unsignedByte);
+#else
         Exiv2::Value::AutoPtr value = Exiv2::Value::create(Exiv2::unsignedByte);
+#endif
         value->read("2 0 0 0");
         d->exifMetadata().add(Exiv2::ExifKey("Exif.GPSInfo.GPSVersionID"), value.get());
 
@@ -380,7 +384,11 @@ bool KExiv2::setGPSInfo(const double* co
         if (altitude)
         {
             // Altitude reference: byte "00" meaning "above sea level", "01" mening "behing sea level".
+#if EXIV2_TEST_VERSION(0,28,0)
+            Exiv2::Value::UniquePtr value = Exiv2::Value::create(Exiv2::unsignedByte);
+#else
             Exiv2::Value::AutoPtr value = Exiv2::Value::create(Exiv2::unsignedByte);
+#endif
 
             if ((*altitude) >= 0) value->read("0");
             else               value->read("1");
diff -up libkexiv2-23.04.1/src/kexiv2image.cpp.omv~ libkexiv2-23.04.1/src/kexiv2image.cpp
--- libkexiv2-23.04.1/src/kexiv2image.cpp.omv~	2023-05-18 02:51:42.575015705 +0200
+++ libkexiv2-23.04.1/src/kexiv2image.cpp	2023-05-18 02:56:02.822656653 +0200
@@ -94,13 +94,21 @@ QSize KExiv2::getImageDimensions() const
         Exiv2::ExifData::iterator it = exifData.findKey(key);
 
         if (it != exifData.end() && it->count())
+#if EXIV2_TEST_VERSION(0,28,0)
+            width = it->toUint32();
+#else
             width = it->toLong();
+#endif
 
         Exiv2::ExifKey key2("Exif.Photo.PixelYDimension");
         Exiv2::ExifData::iterator it2 = exifData.findKey(key2);
 
         if (it2 != exifData.end() && it2->count())
+#if EXIV2_TEST_VERSION(0,28,0)
+            height = it2->toUint32();
+#else
             height = it2->toLong();
+#endif
 
         if (width != -1 && height != -1)
             return QSize(width, height);
@@ -114,13 +122,21 @@ QSize KExiv2::getImageDimensions() const
         Exiv2::ExifData::iterator it3 = exifData.findKey(key3);
 
         if (it3 != exifData.end() && it3->count())
+#if EXIV2_TEST_VERSION(0,28,0)
+            width = it3->toUint32();
+#else
             width = it3->toLong();
+#endif
 
         Exiv2::ExifKey key4("Exif.Image.ImageLength");
         Exiv2::ExifData::iterator it4 = exifData.findKey(key4);
 
         if (it4 != exifData.end() && it4->count())
+#if EXIV2_TEST_VERSION(0,28,0)
+            height = it4->toUint32();
+#else
             height = it4->toLong();
+#endif
 
         if (width != -1 && height != -1)
             return QSize(width, height);
@@ -261,7 +277,11 @@ KExiv2::ImageOrientation KExiv2::getImag
 
         if (it != exifData.end() && it->count())
         {
+#if EXIV2_TEST_VERSION(0,28,0)
+            orientation = it->toUint32();
+#else
             orientation = it->toLong();
+#endif
             qCDebug(LIBKEXIV2_LOG) << "Orientation => Exif.MinoltaCs7D.Rotation => " << (int)orientation;
 
             switch(orientation)
@@ -282,7 +302,11 @@ KExiv2::ImageOrientation KExiv2::getImag
 
         if (it != exifData.end() && it->count())
         {
+#if EXIV2_TEST_VERSION(0,28,0)
+            orientation = it->toUint32();
+#else
             orientation = it->toLong();
+#endif
             qCDebug(LIBKEXIV2_LOG) << "Orientation => Exif.MinoltaCs5D.Rotation => " << (int)orientation;
 
             switch(orientation)
@@ -305,7 +329,11 @@ KExiv2::ImageOrientation KExiv2::getImag
 
         if (it != exifData.end() && it->count())
         {
+#if EXIV2_TEST_VERSION(0,28,0)
+            orientation = it->toUint32();
+#else
             orientation = it->toLong();
+#endif
             qCDebug(LIBKEXIV2_LOG) << "Orientation => Exif.Image.Orientation => " << (int)orientation;
             return (ImageOrientation)orientation;
         }
@@ -381,7 +409,11 @@ bool KExiv2::setImageOrientation(ImageOr
 
         if (it != d->exifMetadata().end() && it->count())
         {
+#if EXIV2_TEST_VERSION(0,28,0)
+            RotationMatrix operation((KExiv2Iface::KExiv2::ImageOrientation)it->toUint32());
+#else
             RotationMatrix operation((KExiv2Iface::KExiv2::ImageOrientation)it->toLong());
+#endif
             operation *= orientation;
             (*it) = static_cast<uint16_t>(operation.exifOrientation());
         }
@@ -849,7 +881,11 @@ bool KExiv2::setImageDateTime(const QDat
 
         const std::string &xmpdatetime(dateTime.toString(Qt::ISODate).toLatin1().constData());
 
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Value::UniquePtr xmpTxtVal = Exiv2::Value::create(Exiv2::xmpText);
+#else
         Exiv2::Value::AutoPtr xmpTxtVal = Exiv2::Value::create(Exiv2::xmpText);
+#endif
         xmpTxtVal->read(xmpdatetime);
         d->xmpMetadata().add(Exiv2::XmpKey("Xmp.exif.DateTimeOriginal"),  xmpTxtVal.get());
         d->xmpMetadata().add(Exiv2::XmpKey("Xmp.photoshop.DateCreated"),  xmpTxtVal.get());
diff -up libkexiv2-23.04.1/src/kexiv2iptc.cpp.omv~ libkexiv2-23.04.1/src/kexiv2iptc.cpp
--- libkexiv2-23.04.1/src/kexiv2iptc.cpp.omv~	2023-05-18 02:32:11.232424696 +0200
+++ libkexiv2-23.04.1/src/kexiv2iptc.cpp	2023-05-18 02:57:11.672349475 +0200
@@ -18,7 +18,12 @@ bool KExiv2::canWriteIptc(const QString&
 {
     try
     {
-        Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((const char*)
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image = 
+#else
+        Exiv2::Image::AutoPtr image = 
+#endif
+                                      Exiv2::ImageFactory::open((const char*)
                                       (QFile::encodeName(filePath).constData()));
 
         Exiv2::AccessMode mode = image->checkMode(Exiv2::mdIptc);
@@ -28,7 +33,12 @@ bool KExiv2::canWriteIptc(const QString&
     {
         std::string s(e.what());
         qCCritical(LIBKEXIV2_LOG) << "Cannot check Iptc access mode using Exiv2 (Error #"
-                                  << e.code() << ": " << s.c_str() << ")";
+#if EXIV2_TEST_VERSION(0,28,0)
+                                  << Exiv2::Error(e.code()).what()
+#else
+                                  << e.code() << ": " << s.c_str()
+#endif
+                                  << ")";
     }
     catch(...)
     {
@@ -80,7 +90,11 @@ QByteArray KExiv2::getIptc(bool addIrbHe
                 c2 = Exiv2::IptcParser::encode(d->iptcMetadata());
             }
 
+#if EXIV2_TEST_VERSION(0,28,0)
+            QByteArray data((const char*)c2.c_data(), c2.size());
+#else
             QByteArray data((const char*)c2.pData_, c2.size_);
+#endif
             return data;
 
         }
@@ -510,7 +524,11 @@ bool KExiv2::setIptcTagsStringList(const
             QString key = *it;
             key.truncate(maxSize);
 
+#if EXIV2_TEST_VERSION(0,28,0)
+            Exiv2::Value::UniquePtr val = Exiv2::Value::create(Exiv2::string);
+#else
             Exiv2::Value::AutoPtr val = Exiv2::Value::create(Exiv2::string);
+#endif
             val->read(key.toUtf8().constData());
             iptcData.add(iptcTag, val.get());
         }
@@ -611,7 +629,11 @@ bool KExiv2::setIptcKeywords(const QStri
             QString key = *it;
             key.truncate(64);
 
+#if EXIV2_TEST_VERSION(0,28,0)
+            Exiv2::Value::UniquePtr val = Exiv2::Value::create(Exiv2::string);
+#else
             Exiv2::Value::AutoPtr val = Exiv2::Value::create(Exiv2::string);
+#endif
             val->read(key.toUtf8().constData());
             iptcData.add(iptcTag, val.get());
         }
@@ -705,7 +727,11 @@ bool KExiv2::setIptcSubjects(const QStri
             QString key = *it;
             key.truncate(236);
 
+#if EXIV2_TEST_VERSION(0,28,0)
+            Exiv2::Value::UniquePtr val = Exiv2::Value::create(Exiv2::string);
+#else
             Exiv2::Value::AutoPtr val = Exiv2::Value::create(Exiv2::string);
+#endif
             val->read(key.toUtf8().constData());
             iptcData.add(iptcTag, val.get());
         }
@@ -800,7 +826,11 @@ bool KExiv2::setIptcSubCategories(const
             QString key = *it;
             key.truncate(32);
 
+#if EXIV2_TEST_VERSION(0,28,0)
+            Exiv2::Value::UniquePtr val = Exiv2::Value::create(Exiv2::string);
+#else
             Exiv2::Value::AutoPtr val = Exiv2::Value::create(Exiv2::string);
+#endif
             val->read(key.toUtf8().constData());
             iptcData.add(iptcTag, val.get());
         }
diff -up libkexiv2-23.04.1/src/kexiv2_p.cpp.omv~ libkexiv2-23.04.1/src/kexiv2_p.cpp
--- libkexiv2-23.04.1/src/kexiv2_p.cpp.omv~	2023-05-18 02:30:45.448625174 +0200
+++ libkexiv2-23.04.1/src/kexiv2_p.cpp	2023-05-18 03:07:22.953440588 +0200
@@ -76,9 +76,17 @@ bool KExiv2Private::saveToXMPSidecar(con
 
     try
     {
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image;
+#else
         Exiv2::Image::AutoPtr image;
+#endif
         image = Exiv2::ImageFactory::create(Exiv2::ImageType::xmp, (const char*)(QFile::encodeName(filePath).constData()));
+#if EXIV2_TEST_VERSION(0,28,0)
+        return saveOperations(finfo, std::move(image));
+#else
         return saveOperations(finfo, image);
+#endif
     }
     catch( Exiv2::Error& e )
     {
@@ -155,9 +163,17 @@ bool KExiv2Private::saveToFile(const QFi
 
     try
     {
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image;
+#else
         Exiv2::Image::AutoPtr image;
+#endif
         image = Exiv2::ImageFactory::open((const char*)(QFile::encodeName(finfo.filePath()).constData()));
+#if EXIV2_TEST_VERSION(0,28,0)
+        return saveOperations(finfo, std::move(image));
+#else
         return saveOperations(finfo, image);
+#endif
     }
     catch( Exiv2::Error& e )
     {
@@ -171,7 +187,11 @@ bool KExiv2Private::saveToFile(const QFi
     }
 }
 
+#if EXIV2_TEST_VERSION(0,28,0)
+bool KExiv2Private::saveOperations(const QFileInfo& finfo, Exiv2::Image::UniquePtr image) const
+#else
 bool KExiv2Private::saveOperations(const QFileInfo& finfo, Exiv2::Image::AutoPtr image) const
+#endif
 {
     try
     {
@@ -345,7 +365,12 @@ void KExiv2Private::printExiv2ExceptionE
 {
     std::string s(e.what());
     qCCritical(LIBKEXIV2_LOG) << msg.toLatin1().constData() << " (Error #"
-                              << e.code() << ": " << s.c_str();
+#if EXIV2_TEST_VERSION(0,28,0)
+                              << Exiv2::Error(e.code()).what()
+#else
+                              << e.code() << ": " << s.c_str()
+#endif
+                              << ")";
 }
 
 void KExiv2Private::printExiv2MessageHandler(int lvl, const char* msg)
@@ -599,7 +624,11 @@ int KExiv2Private::getXMPTagsListFromPre
 }
 
 #ifdef _XMP_SUPPORT_
+#if EXIV2_TEST_VERSION(0,28,0)
+void KExiv2Private::loadSidecarData(Exiv2::Image::UniquePtr xmpsidecar)
+#else
 void KExiv2Private::loadSidecarData(Exiv2::Image::AutoPtr xmpsidecar)
+#endif
 {
     // Having a sidecar is a special situation.
     // The sidecar data often "dominates", see in particular bug 309058 for important aspects:
diff -up libkexiv2-23.04.1/src/kexiv2_p.h.omv~ libkexiv2-23.04.1/src/kexiv2_p.h
--- libkexiv2-23.04.1/src/kexiv2_p.h.omv~	2023-05-18 02:29:19.814827553 +0200
+++ libkexiv2-23.04.1/src/kexiv2_p.h	2023-05-18 02:30:43.242604620 +0200
@@ -94,7 +94,11 @@ public:
 
     bool saveToXMPSidecar(const QFileInfo& finfo)                            const;
     bool saveToFile(const QFileInfo& finfo)                                  const;
+#if EXIV2_TEST_VERSION(0,28,0)
+    bool saveOperations(const QFileInfo& finfo, Exiv2::Image::UniquePtr image) const;
+#else
     bool saveOperations(const QFileInfo& finfo, Exiv2::Image::AutoPtr image) const;
+#endif
 
     /** Wrapper method to convert a Comments content to a QString.
      */
@@ -125,8 +129,12 @@ public:
 #ifdef _XMP_SUPPORT_
     Exiv2::XmpData&        xmpMetadata()         { return data.data()->xmpMetadata;        }
 
+#if EXIV2_TEST_VERSION(0,28,0)
+    void loadSidecarData(Exiv2::Image::UniquePtr xmpsidecar);
+#else
     void loadSidecarData(Exiv2::Image::AutoPtr xmpsidecar);
 #endif
+#endif
 
 public:
 
diff -up libkexiv2-23.04.1/src/kexiv2previews.cpp.omv~ libkexiv2-23.04.1/src/kexiv2previews.cpp
--- libkexiv2-23.04.1/src/kexiv2previews.cpp.omv~	2023-05-18 02:58:04.857883376 +0200
+++ libkexiv2-23.04.1/src/kexiv2previews.cpp	2023-05-18 03:08:00.902816499 +0200
@@ -29,9 +29,17 @@ public:
         delete manager;
     }
 
+#if EXIV2_TEST_VERSION(0,28,0)
+    void load(Exiv2::Image::UniquePtr image_)
+#else
     void load(Exiv2::Image::AutoPtr image_)
+#endif
     {
+#if EXIV2_TEST_VERSION(0,28,0)
+        image                              = std::move(image_);
+#else
         image                              = image_;
+#endif
 
         image->readMetadata();
 
@@ -49,7 +57,11 @@ public:
 
 public:
 
+#if EXIV2_TEST_VERSION(0,28,0)
+    Exiv2::Image::UniquePtr         image;
+#else
     Exiv2::Image::AutoPtr           image;
+#endif
     Exiv2::PreviewManager*          manager;
     QList<Exiv2::PreviewProperties> properties;
 };
@@ -59,8 +71,13 @@ KExiv2Previews::KExiv2Previews(const QSt
 {
     try
     {
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open((const char*)(QFile::encodeName(filePath).constData()));
+        d->load(std::move(image));
+#else
         Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((const char*)(QFile::encodeName(filePath).constData()));
         d->load(image);
+#endif
     }
     catch( Exiv2::Error& e )
     {
@@ -77,8 +94,13 @@ KExiv2Previews::KExiv2Previews(const QBy
 {
     try
     {
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image = Exiv2::ImageFactory::open((Exiv2::byte*)imgData.data(), imgData.size());
+        d->load(std::move(image));
+#else
         Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((Exiv2::byte*)imgData.data(), imgData.size());
         d->load(image);
+#endif
     }
     catch( Exiv2::Error& e )
     {
diff -up libkexiv2-23.04.1/src/kexiv2xmp.cpp.omv~ libkexiv2-23.04.1/src/kexiv2xmp.cpp
--- libkexiv2-23.04.1/src/kexiv2xmp.cpp.omv~	2023-05-18 02:35:02.288020183 +0200
+++ libkexiv2-23.04.1/src/kexiv2xmp.cpp	2023-05-18 03:01:04.858683400 +0200
@@ -19,7 +19,12 @@ bool KExiv2::canWriteXmp(const QString&
 #ifdef _XMP_SUPPORT_
     try
     {
-        Exiv2::Image::AutoPtr image = Exiv2::ImageFactory::open((const char*)
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Image::UniquePtr image =
+#else
+        Exiv2::Image::AutoPtr image = 
+#endif
+                                      Exiv2::ImageFactory::open((const char*)
                                       (QFile::encodeName(filePath).constData()));
 
         Exiv2::AccessMode mode = image->checkMode(Exiv2::mdXmp);
@@ -29,7 +34,12 @@ bool KExiv2::canWriteXmp(const QString&
     {
         std::string s(e.what());
         qCCritical(LIBKEXIV2_LOG) << "Cannot check Xmp access mode using Exiv2 (Error #"
-                    << e.code() << ": " << s.c_str() << ")";
+#if EXIV2_TEST_VERSION(0,28,0)
+                    << Exiv2::Error(e.code()).what()
+#else
+                    << e.code() << ": " << s.c_str()
+#endif
+                    << ")";
     }
     catch(...)
     {
@@ -374,7 +384,11 @@ bool KExiv2::setXmpTagString(const char*
     try
     {
         const std::string &txt(value.toUtf8().constData());
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Value::UniquePtr xmpTxtVal = Exiv2::Value::create(Exiv2::xmpText);
+#else
         Exiv2::Value::AutoPtr xmpTxtVal = Exiv2::Value::create(Exiv2::xmpText);
+#endif
         xmpTxtVal->read(txt);
         d->xmpMetadata()[xmpTagName].setValue(xmpTxtVal.get());
         return true;
@@ -515,7 +529,11 @@ bool KExiv2::setXmpTagStringListLangAlt(
 
         if (!values.isEmpty())
         {
+#if EXIV2_TEST_VERSION(0,28,0)
+            Exiv2::Value::UniquePtr xmpTxtVal = Exiv2::Value::create(Exiv2::langAlt);
+#else
             Exiv2::Value::AutoPtr xmpTxtVal = Exiv2::Value::create(Exiv2::langAlt);
+#endif
 
             for (AltLangMap::const_iterator it = values.constBegin(); it != values.constEnd(); ++it)
             {
@@ -621,7 +639,11 @@ bool KExiv2::setXmpTagStringLangAlt(cons
         QString txtLangAlt = QString(QString::fromLatin1("lang=%1 %2")).arg(language).arg(value);
 
         const std::string &txt(txtLangAlt.toUtf8().constData());
+#if EXIV2_TEST_VERSION(0,28,0)
+        Exiv2::Value::UniquePtr xmpTxtVal = Exiv2::Value::create(Exiv2::langAlt);
+#else
         Exiv2::Value::AutoPtr xmpTxtVal = Exiv2::Value::create(Exiv2::langAlt);
+#endif
 
         // Search if an Xmp tag already exist.
 
@@ -735,7 +757,11 @@ bool KExiv2::setXmpTagStringSeq(const ch
         else
         {
             const QStringList list = seq;
+#if EXIV2_TEST_VERSION(0,28,0)
+            Exiv2::Value::UniquePtr xmpTxtSeq = Exiv2::Value::create(Exiv2::xmpSeq);
+#else
             Exiv2::Value::AutoPtr xmpTxtSeq = Exiv2::Value::create(Exiv2::xmpSeq);
+#endif
 
             for (QStringList::const_iterator it = list.constBegin(); it != list.constEnd(); ++it )
             {
@@ -835,7 +861,11 @@ bool KExiv2::setXmpTagStringBag(const ch
         else
         {
             QStringList list = bag;
+#if EXIV2_TEST_VERSION(0,28,0)
+            Exiv2::Value::UniquePtr xmpTxtBag = Exiv2::Value::create(Exiv2::xmpBag);
+#else
             Exiv2::Value::AutoPtr xmpTxtBag = Exiv2::Value::create(Exiv2::xmpBag);
+#endif
 
             for (QStringList::const_iterator it = list.constBegin(); it != list.constEnd(); ++it )
             {
@@ -929,7 +959,11 @@ QVariant KExiv2::getXmpTagVariant(const
                 case Exiv2::unsignedLong:
                 case Exiv2::signedShort:
                 case Exiv2::signedLong:
+#if EXIV2_TEST_VERSION(0,28,0)
+                    return QVariant((int)it->toUint32());
+#else
                     return QVariant((int)it->toLong());
+#endif
                 case Exiv2::unsignedRational:
                 case Exiv2::signedRational:
                     if (rationalAsListOfInts)
